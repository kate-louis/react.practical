### 추천하는 컴포넌트 파일 작성법
* 가장 상단에 속성값의 타입을 정의  
* 컴포넌트 함수 작성, 컴포넌트의 이름 작성 추천
* 컴포넌트 바깥에 있는 변수와 함수는 파일의 가장 밑에 정의하는게 좋음
* 컴포넌트 내부에서 서로 연관된 코드는 한곳으로 모아서 관리하는게 좋음

### 속성값 타입 정의하기: prop-types
* prop-types 패키지는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공색 패키지

### 가독성을 높이는 조건부 렌더링 방법
* 컴포넌트 함수 내부에서 특정값에 따라 선택적으로 렌더링하는 것을 조건부 렌더링이라고 한다
* jsx 부분에서 false를 표현하면 이것은 리액트에서 무시가 됨,  
null 같은 것도 무시가 됨 
```
const v1 = 'ab' && 0 && 2; // v1 === 0
const v2 = 'ab' && 2 && 3; // v2 === 3
const v3 = 'ab' || 0; //v3 === 'ab'
const v4 = '' || 0 || 3; // v4 === 3 

// && 연산자는 처음으로 거짓을 만나거나 아니면 끝까지 이동할 떄까지 평가
// || 연산자는 처음으로 참을 만날 때까지만 평가

<div>{students ** students.map(/* */)}</div>
// undefined를 검사하고 있는 코드
```

### 재사용성을 고려한 컴포넌트 구분법
* 코드의 재사용성과 가독성을 올리려면 관심사의 분리가 필요,    
프로그래밍에서 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 모아서 별도로 관리하는 것을 말한다
* 자식 컴포넌트에서 부모의 데이터를 별도의 상태값으로 관리하는 것은 좋지 않다, 상태값은 일부 컴포넌트로 한정해서 관리하는 게 좋음
* 비지니스 로직과 상태값의 유무로 컴포넌트를 분리하는 것을 추천,  
재사용이 좋은 컴포넌트와 그렇지 않은 컴포넌트로 구분
* 재사용성이 좋은 컴포넌트의 정의  
-비지니스 로직이 없다   
-상태값이 없다. 단, 마우스 오버와 같은 UI 효과를 위한 상탯값은 제외한다
* component 폴더에는 재사용성이 높은 컴포넌트를 넣고,  
재사용성이 낮은 컴포넌트를 container 폴더에 넣는다 

### useEffect 실전 활용법1
```
// 1번
useEffect(() => {
  fetchUser(userId).then(data => setUser(data));
}, [userId]);

// 2번
useEffect(() => {
  async function fetchAndSetUser() {
    ...
  }
  fetchAndSetUser();
}, [userId]);

// 3번
const fetchAndSetUser = useCallback(
  async function() { ... }, 
  [userId],
);
useEffect(() => {
  fetchAndSetUser(false);
}, [fetchAndSetUser])
```
* 1번) 해당 컴포넌트가 렌더링될 때마다 useEffect의 부수효과 함수가 호출되서 서버의 api를 호출하는 코드가 항상 실행됨,  
문제 해결을 위해 의존성 배열로 작성
* 부수효과 함수 안에서 사용된 상태값이나 속성값 또는 그 두가지 값으로 계산된 어떤 값이 있을 때 항상 그 값은 의존성 배열에 나열을 해줘야함
* 부수효과 함수가 새로 생성되어도 의존성 배열에 해당 값이 없으면,  
리액트는 방금 생성된 부수효과 함수를 무시하고 예전에 생성된 부수효과 함수를 계속 사용
* 2번) 부수효과 함수의 반환값은 항상 함수 타입이어야 함,
async await 함수는 Promise 객체를 반환하기 때문에 부수효과 함수가 될 수 없음
* 3번) fetchAndSetUser 함수는 해당 컴포넌트가 렌더링될 때마다 생성되고 의존성 배열의 내용이 항상 변하는 거고  
이 부수효과 함수도 렌더링될 떄마다 실행됨, 해결책은 useCallback 훅

### useEffect 실전 활용법2
```
// 1번
useEffect(() => {
  if(!user || user.id !== userId) {
    fetchAndSetUser(false);
  }
});

// 2번
useEffect(() => {
  setCount(prev => prev + 1);
});
```
* 가능하다면 의존성 배열을 사용하지 않는 게 좋습니다, 의존성 배열을 관리하는데 생각보다 많은 시간과 노력이 들어가기 떄문
* 1번) 의존성 배열을 입력하지 않는 대신 부수효과 함수 내에서 실행 시점을 조절할 수 있음, 최신화된 값을 참조하므로 안심할 수 있음
* 2번) 상태값 변경 함수에 함수를 입력할 때는 이 함수의 매개변수로 이전 상태값이 들어온다
* 여러 상태값을 참조하면서 값을 변경할 때는 useReducer 훅을 사용하는게 좋음

### 렌더링 속도를 올리기 위한 성능 최적화 방법1
* component(data) => 가상 돔과의 비교 => 실제 돔에 반영
-리액트는 데이터와 컴포넌트 함수로 화면을 그린다  
-여기서 데이터는 컴포넌트의 속성값과 상태값을 말한다  
-속성값이나 상태값이 변경되면 리액트가 자동으로 컴포넌트 함수를 이용해서 화면을 다시 그린다
* 평상시에는 성능 최적화를 고민하지 말고 어쩌다 한번 성능 이슈가 생기면 그때 고민하라
*****
**React.memo**
```
React.memo(MyComponent, isEqual);

// 단순 비교
prevProps.todos === nextProps.todos

// 불변 객체로 관리
const todos = [1, 2, 3];
const nextTodos = [...todos, 4];
``` 
* 리액트 memo 함수로 감싼 컴포넌트라면 속성값 비교 함수가 호출됨
* 속성값 비교 함수는 이전/이후 속성값을 매개변수로 받아서 참 또는 거짓을 반환,   
참이면 이전 렌더링 결과 재사용, 거짓이면 컴포넌트 함수를 실행해서 가상돔을 업데이트하고 변경된 부분만 실제 돔에 반영
* 속성값 비교 함수가 항상 거짓을 반환 하더라도 속성값이 변경되지 않았다면 실제돔도 변경되지 않기 떄문에 대부분 문제가 되지 않는다
* 데이터를 불변 데이터로 관리하면 이전/이후 값의 단순 비교만으로 컴포넌트의  속성값이 변경 됐는지 알 수 있음,  
상태값을 불변 객체로 관리하면 렌더링 선능에 큰 도움이 된다
* 불변 객체로 관리한다는 것은 새로운 객체를 만드는 방식
* 리액트에서 기본으로 사용하는 속성값 비교 함수는 얕은 비교를 한다

### 렌더링 속도를 올리기 위한 성능 최적화 방법2
***값이 너무 자주 변경되서 문제가 되는 경우***
```
// 1번
<SelectFruit onChange={fruit => setSelectedFruit(fruit)} />

// 2번
<SelectFruit onChange={setSelectedFruit} />

// 3번
const onChangeFruit = useCallback(fruit => { ... }, []);
<SelectFruit onChange={onChangeFruit} />

// 4번
<Select option={[ ... ]} />

// 5번
<Select option={FRUITS} />
const FRUITS = [ ... ];

// 6번
const fruit = useMemo(() => FRUITS.filter( ... ), [maxPrice]);

```
* 1번) 이렇게 함수를 작성하면 매번 렌더링 할 때마다 새로운 값이 입력되어 리액트 memo를 사용했더라도 이 컴포넌트는 부모가 렌더링 될때마다 렌더링 됩니다
* 2번) 해결방안: 상태값 변경 함수를 그대로 입력해주면 해결,   
상태값 변경 함수는 한 번 생성되고 변경되지 않기 때문에 
* 3번) 간단하지 않으면 useCallback 이용
* 4번) 컴포넌트 내부에서 객체를 정의해서 자식 컴포넌트의 속성값으로 입력하면,  
객체의 내용이 변경되지 않아도 자식 컴포넌트 입장에서는 속성값이 변경되었다고 인식함
* 5번) 고정된 값이면 상수 변수로 관리
* 6번) useMemo 훅을 이용하면 필요할 떄만 값이 변경되도록 할 수 있다
* useMemo, useCallback, React.memo 같은 것은 미리 성능을 걱정해서 사용하는 걸 추천하지 않음

***값이 변경되지 않아 문제가 되는 경우***
```
// 1번
fruits.push(newFruit); // 상태값을 직접 수정
setNewFruit(''); // 이 코드에 의해서 렌더링

// 2번
setFruits(...fruits, newFruit);
```
* 1번) 값이 실제로 변경됐음에도 이 값의 레퍼런스는 지금 변경되지 않았기 떄문에,
리액트 입장에서는 이 상태값은 변경되지 않은 것
* 2번) 상태값은 불변 객체로 관리해야 한다

### 렌더링 속도를 올리기 위한 성능 최적화 방법3
```
// 1번
<UserDetail key={user.id} user={user} />
```
* children 부분은 같고 부모의 태그가 다르면,
이렇게 요소의 타입을 변경하면 해당 요소의 모든 자식 요소도 같이 변경된다
* 요소의 타입을 변경하는게 아니라 속성값만 변경했을 때는 해당하는 속성만 수정이 됩니다
* 리액트는 중간에 요소를 추가하면 그 뒤에 있는 요소가 변경되지 않았다는 것을 알지 못한다,  
리액트는 효율적으로 연산하기 위해서 순서 정보를 이용한다,
key 속성값을 이용하면 리액트는 같은 key를 갖은 요소끼리만 비교한다
* 데이터의 아이디 값을 key 속성값에 입력하는게 좋다
key속성값에 순서 정보를 입력하는 것은 배열 원소의 순서를 변경하지 않는 경우에만 적합
* key를 이용해서 의도적으로 컴포넌트를 언마운트 시키는게 유용할 때가 있다  
1번) 만약 유저 데이터가 변경됐을 때 컴포넌트 안에서 유지하던 상태값을 초기화 하고 싶을 때 사용
