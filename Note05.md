### 추천하는 컴포넌트 파일 작성법
* 가장 상단에 속성값의 타입을 정의  
* 컴포넌트 함수 작성, 컴포넌트의 이름 작성 추천
* 컴포넌트 바깥에 있는 변수와 함수는 파일의 가장 밑에 정의하는게 좋음
* 컴포넌트 내부에서 서로 연관된 코드는 한곳으로 모아서 관리하는게 좋음

### 속성값 타입 정의하기: prop-types
* prop-types 패키지는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공색 패키지

### 가독성을 높이는 조건부 렌더링 방법
* 컴포넌트 함수 내부에서 특정값에 따라 선택적으로 렌더링하는 것을 조건부 렌더링이라고 한다
* jsx 부분에서 false를 표현하면 이것은 리액트에서 무시가 됨,  
null 같은 것도 무시가 됨 
```
const v1 = 'ab' && 0 && 2; // v1 === 0
const v2 = 'ab' && 2 && 3; // v2 === 3
const v3 = 'ab' || 0; //v3 === 'ab'
const v4 = '' || 0 || 3; // v4 === 3 

// && 연산자는 처음으로 거짓을 만나거나 아니면 끝까지 이동할 떄까지 평가
// || 연산자는 처음으로 참을 만날 때까지만 평가

<div>{students ** students.map(/* */)}</div>
// undefined를 검사하고 있는 코드
```

### 재사용성을 고려한 컴포넌트 구분법
* 코드의 재사용성과 가독성을 올리려면 관심사의 분리가 필요,    
프로그래밍에서 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 모아서 별도로 관리하는 것을 말한다
* 자식 컴포넌트에서 부모의 데이터를 별도의 상태값으로 관리하는 것은 좋지 않다, 상태값은 일부 컴포넌트로 한정해서 관리하는 게 좋음
* 비지니스 로직과 상태값의 유무로 컴포넌트를 분리하는 것을 추천,  
재사용이 좋은 컴포넌트와 그렇지 않은 컴포넌트로 구분
* 재사용성이 좋은 컴포넌트의 정의
-비지니스 로직이 없다  
-상탯값이 없다. 단, 마우스 오버와 같은 UI 효과를 위한 상탯값은 제외한다
* component 폴더에는 재사용성이 높은 컴포넌트를 넣고,  
재사용성이 낮은 컴포넌트를 container 폴더에 넣는다 

### useEffect 실전 활용법1
```
// 1번
useEffect(() => {
  fetchUser(userId).then(data => setUser(data));
}, [userId]);

// 2번
useEffect(() => {
  async function fetchAndSetUser() {
    ...
  }
  fetchAndSetUser();
}, [userId]);

// 3번
const fetchAndSetUser = useCallback(
  async function() { ... }, 
  [userId],
);
useEffect(() => {
  fetchAndSetUser(false);
}, [fetchAndSetUser])
```
* 1번) 해당 컴포넌트가 렌더링될 때마다 useEffect의 부수효과 함수가 호출되서 서버의 api를 호출하는 코드가 항상 실행됨, 문제 해결을 위해 의존성 배열로 작성
* 부수효과 함수 안에서 사용된 상태값이나 속성값 또는 그 두가지 값으로 계산된 어떤 값이 있을 때 항상 그 값은 의존성 배열에 나열을 해줘야함
* 부수효과 함수가 새로 생성되어도 의존성 배열에 해당 값이 없으면,  
리액트는 방금 생성된 부수효과 함수를 무시하고 예전에 생성된 부수효과 함수를 계속 사용
* 2번) 부수효과 함수의 반환값은 항상 함수 타입이어야 함,
async await 함수는 Promise 객체를 반환하기 때문에 부수효과 함수가 될 수 없음
* 3번) fetchAndSetUser 함수는 해당 컴포넌트가 렌더링될 때마다 생성되고 의존성 배열의 내용이 항상 변하는 거고 이 부수효과 함수도 렌더링될 떄마다 실행됨, 해결책은 useCallback 훅

### useEffect 실전 활용법2
```
// 1번
useEffect(() => {
  if(!user || user.id !== userId) {
    fetchAndSetUser(false);
  }
});

// 2번
useEffect(() => {
  setCount(prev => prev + 1);
});
```
* 가능하다면 의존성 배열을 사용하지 않는 게 좋습니다, 의존성 배열을 관리하는데 생각보다 많은 시간과 노력이 들어가기 떄문
* 1번) 의존성 배열을 입력하지 않는 대신 부수효과 함수 내에서 실행 시점을 조절할 수 있음, 최신화된 값을 참조하므로 안심할 수 있음
* 2번) 상태값 변경 함수에 함수를 입력할 때는 이 함수의 매개변수로 이전 상태값이 들어온다
* 여러 상태값을 참조하면서 값을 변경할 때는 useReducer 훅을 사용하는게 좋음

### 렌더링 속도를 올리기 위한 성능 최적화 방법1
* component(data) => 가상 돔과의 비교 => 실제 돔에 반영
-리액트는 데이터와 컴포넌트 함수로 화면을 그린다  
-여기서 데이터는 컴포넌트의 속성값과 상태값을 말한다  
-속성값이나 상태값이 변경되면 리액트가 자동으로 컴포넌트 함수를 이용해서 화면을 다시 그린다
* 평상시에는 성능 최적화를 고민하지 말고 어쩌다 한번 성능 이슈가 생기면 그때 고민하라
*****
**React.memo**
```
React.memo(MyComponent, isEqual);

// 단순 비교
prevProps.todos === nextProps.todos

// 불변 객체로 관리
const todos = [1, 2, 3];
const nextTodos = [...todos, 4];
``` 
* 리액트 memo 함수로 감싼 컴포넌트라면 속성값 비교 함수가 호출됨
* 속성값 비교 함수는 이전/이후 속성값을 매개변수로 받아서 참 또는 거짓을 반환, 
참이면 이전 렌더링 결과 재사용, 거짓이면 컴포넌트 함수를 실행해서 가상돔을 업데이트하고 변경된 부분만 실제 돔에 반영
* 속성값 비교 함수가 항상 거짓을 반환 하더라도 속성값이 변경되지 않았다면 실제돔도 변경되지 않기 떄문에 대부분 문제가 되지 않는다
* 데이터를 불변 데이터로 관리하면 이전/이후 값의 단순 비교만으로 컴포넌트의  속성값이 변경 됐는지 알 수 있음,  
상태값을 불변 객체로 관리하면 렌더링 선능에 큰 도움이 된다
* 불변 객체로 관리한다는 것은 새로운 객체를 만드는 방식
* 리액트에서 기본으로 사용하는 속성값 비교 함수는 얕은 비교를 한다

### 렌더링 속도를 올리기 위한 성능 최적화 방법2

### 렌더링 속도를 올리기 위한 성능 최적화 방법3
