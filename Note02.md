### 리액트를 사용한 코드의 특징
```
const [todoList, setTodoList] = useState([]);
```
* todoList 상태값  
useState 함수를 호출하면 컴포넌트에 상태값을 추가할 수 있다  
useState의 매개변수는 상태값의 초기값을 의미한다  
useState는 배열을 반환하는데 첫번째 아이템은 상태값, 두번째 아이템은 상태값 변경 함수  
상태값이 변경되면 리액트는 자동으로 UI를 변경해 준다  
* JSX 부분에서 배열을 표현할 때는 항상 key를 입력해 주어야 한다. (효율적인 업데이트)
* 비구조화 문법 / 전개 연산자
* 리액트쪽 코드 특징 - 이벤트 핸들러에서 데이터를 변경하는 작업만 한다 , 비지니스 로직과 UI 코드가 분리되어 있음, 기존 HTML은 명령형 프로그래밍 vs 리액트는 선언형 프로그래밍

### 컴포넌트의 속성값과 상탯값
* 리액트 컴포넌트에서는 UI 데이터를 속성값이나 상태값으로 관리해야 한다
* 리액트가 값에 변경 사실을 알려면 상태값으로 관리해야 한다
* props라는 값은 부모 컴포넌트가 전달해 주는 속성값이다
* 부모 컴포넌트가 렌더링될 때마다 자식 컴포넌트도 같이 렌더링 된다
* 속성값이 변경될 때만 이 컴포넌트가 렌더링되게 하려면 React.memo를 사용
* 사용된 각 컴포넌트는 상태값을 위한 자신만의 메모리 공간이 있어서 같은 컴포넌트라고 하더라도 자신만의 상태값이 존재한다
* 속성값은 불변 변수 이지만 상태값은 불변 변수가 아니지만 불변 변수로 관리하는게 좋다 (불변변수랑 변수의 값을 바꿀수 없다)
* 리액트는 상태값 변경 유무를 이전 값과의 단순 비교로 판단 한다
* 객체를 불변 변수로 관리하는 방법 중 하나는 전개 연산자 이용하는 것
```
function Title({ title }) { ... }
export default React.memo(Title);
// 속성값 title이 변경될 때만 이 컴포넌트가 렌더링 됨
```

### 컴포넌트 함수의 반환값
**반환값**   
리액트 요소 / 컴포넌트 / 문자열 / 숫자 / 배열 (key 필요) / React.Fragment (실제돔에는 반영이 되지 않음) / null or boolean (값이 무시가 됨, boolean은 조건부 렌더링에 유용) / portal

**React Protal**  
html에서 root 엘리먼트 말고 다른 멀리 떨어진 엘리먼트를 렌더링하고 싶을 때 사용할 수 있음,  모달을 위해서 많이 사용됨
```
// index.html
<div id="root"></div>
<div id="something"></div>

// App.js
import ReactDom from 'react-dom';
export default function App() {
  return (
    <>
      <Counter />
      {ReactDOM.createPortal(
        <div></div>,
        document.getElementById('something'),
      )}
    </>
  );
}
```

### 리액트 요소와 가상돔1
* 리액트는 렌더링 성능을 위해 가상돔이라는 것을 활용, 리액트는 메모리에 가상돔을 올려 놓고 이전과 이후의 가상돔을 비교한다, 변경된 부분만 실제 돔에 반영
* 객체 형식으로 리액트 요소가 이루어져 있음, 리액트 요소는 불변 객체
* key를 변경하면 리액트는 이것은 다른 요소라고 판단하여 이전 것을 삭제하고 새로 만들어서 붙힌다, 컴포넌트의 key를 변경하면 해당 컴포넌트는 삭제되었다가 다시 추가가 된다
* 컴포넌트가 삭제 (unmount) / 컴포넌트 추가 (mount)  
컴포넌트가 mount될 때 useState에 초기값이 상태값으로 할당이 됨

### 리액트 요소와 가상돔2
* 하나의 리액트 요소 트리는 시간에 따라 변화하는 화면의 한 순간을 나타낸다고 볼 수 있습니다
* 데이터 변경에 의한 화면 업데이트는 렌더단계와 커밋단계를 거친다  
렌더 단계(가상돔): 실제 돔에 반영할 변경사항을 파악하는 단계  
커밋 단계(실제돔): 파악된 변경 사항을 실제 돔에 반영하는 단계
* 리액트는 화면을 업데이트할 때 이전에 가상 돔과 현재의 가상돔을 비교해서 변경된 부분만 실제 돔에 반영

### 리액트 훅 기초 익히기1
**리액트 훅(hook)**
* 컴포넌트에 기능을 추가할 때 사용하는 함수  
* useState: 상태값 추가  
* useEffect: 부수효과 처리 (서버 API 호출, 이벤트 핸드러 등록 등)  
부수 효과란 외부의 상태를 변경하는 것

**상태값 변경 함수**
* 상태값 변경 함수는 비동기이면서 배치(batch)로 처리됨  
해결방안: 상태값 변경 함수에 함수를 입력하는 방법, 처리되기 직전의 상태값을 매개변수로 받기 때문에 원하는 대로 동작
* 상태값 변경 함수는 호출한 순서대로 적용이 된다
* 여러개의 상태값을 하나의 useState로 관리할 수 있음, 객체 이용, 상태값 변경 함수를 호출할 때 전체 객체를 새로 입력해 줘야함, useReducer가 더 적합

**useEffect 훅**
* 특별한 이유가 없다면 모든 부수 효과는 useEffect 훅에서 처리하는게 좋음
* 첫번째 매개변수로 입력한 함수는 컴포넌트가 렌더링된 후에 호출, 렌더링 결과가 실제 돔에 반영되고 비동기로 호출

### 리액트 훅 기초 익히기2
**useEffect 훅**
* 두 번쨰 매개 변수에 배열을 입력, 의존성 배열, 이 배열에 있는 값이 변경될 때만 부수 효과 함수가 실행됨
* 의존성 배열에 빈 배열을 입력하면 부수 효과 함수는 마운트된 이후에 한 번만 호출됨
* 의존성 배열에는 부수 효과 함수에서 사용한 변수 중 컴포넌트의 상태값이나 속성값 또는 이 컴포넌트 내부에 정의된 지역 변수나 지역 함수 같은 것들은 모두 작성해 줘야함, 외부 함수는 입력하지 않아도 됨, 상태값 변경 함수는 예외적으로 입력하지 않아도 됨
* 의존성 배열은 꼭 필요할 때만 입력하는게 좋음
* 부수 효과 함수에서 반환하는 함수는 다음 부수 효과 함수가 호출되기 직전에 호출 또는 컴포넌트가 unmount 되기 직전에 마지막으로 호출됨

### 훅 직접 만들기
**커스텀 훅**
* 훅을 직접 만들어서 사용하면 쉽게 로직을 재사용할 수 있다
* 내장 훅처럼 커스텀 훅의 이름은 use로 시작하는게 좋다
* useState나 useEffect 라는 기존 훅을 이용해서 새로운 훅을 만들 수 있다

### 훅 사용 시 지켜야 할 규칙
* 규칙 1: 하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야 한다  
-if문 안에서 사용 X, for문 안에서 사용 X, 함수 안에서 훅을 호출 X  
-return 문 다음에 훅이 위치 X, jsx 코드를 return 코드와 붙여서 작성 권장  
-리액트 내부에서는 각 훅이 사용된 위치 정보를 기반으로 훅 데이터를 관리  
* 규칙 2: 훅은 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다
